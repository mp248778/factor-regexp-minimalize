It's an implementation of standart nlogn Hopcrofts algorithm based on http://www.liafa.jussieu.fr/~carton/Enseignement/Complexite/ENS/Redaction/Annee-0809/yingjie.xu.pdf [1].


TUPLE: Subset elems id ;
TUPLE: Partitions sets ;
	It is a list of current subsets, each state is in exacly one subset.

TUPLE: Working-set sets-vector sets-ids ;
	sets-ids is a list of all sets by which the partitioning should take place.
	sets-vector is a hashtable subset.id -> subset of subsets from sets-ids

TUPLE: Minimize-State partitions working-set ;
	Just packs these two values together

The code first constructs an inverse transition table(later referenced as itt) 
 and prepares first subsets for work. it is worth mentioning that after constructing 
the itt the alphabet is completly forgotten as it is uneeded.

The main loop calls repetadly sub-partition which, given an set, divides all sets in 
such a way that in the end all elements in every set are equal states.

sub-partition :
(the last argument is la from [1] (line 6 in algorithm 3))
First it divides each set into two parts, one beeing the intersection
with la, the second one is the rest. Secondly it renumbers generated
sets in such a way, that :
If a set is completly in or out of la then its number is not changed.
If a set is divided into two, then the first one retains the id, while
the second one gets a new id. 
Thridly working set is updated, according to 10-17 from alg. 3 [1].
Working-set has to be updated carefully in order to not add to sets-id an 
set that is already inside or a set that has been already processed.
In this place the code is a little different as previously it completly
ommited the requirement for R in the for loop [7], this is why adding
to working-set is a little complicated.
